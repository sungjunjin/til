# DB 설계 기초

## 바른 DB 스키마 설계
올바른 DB 스키마 설계를 위한 4가지 원칙은 다음과 같다.

- 의미적으로 관련있는 속성끼리 테이블을 구성
- 중복 데이터를 최대한 허용하지 않도록 설계
- join 수행 시 가짜 데이터가 생기지 않도록 설계
- 되도록이면 null 값을 최대한 줄일 수 있는 방향으로 설계

## 함수적 종속 (Functional Dependency)

함수적 종속이란, 한 테이블에 있는 두 개의 attribute 집합 사이의 제약을 의미한다.

X값에 따라 Y값이 유일하게 결정될 때 다음과 같이 표현할 수 있다.
- X가 Y를 함수적으로 결정한다
- Y가 X를 함수적으로 의존한다

기호는 아래와 같이 표현할 수 있다.

```
X -> Y
```

예를들어 직원을 관리하는 테이블의 empl_id (pk), empl_name, birth_date라는 속성이 있다고 가정해보자.

직원의 고유 id(empl_id)와 직원의 이름(empl_name)은 직원의 생년월일(birth_date)를 결정할 수 있기 때문에 다음 종속성을 가질 수 있다.

- {empl_id, empl_name} -> {birth_date}

더 간단한 예시로 학생과 수업을 관리하는 테이블들은 다음과 같은 함수적 종속을 만족할 수 있다.

- {stu_id} -> {stu_name, birth_date, address}
- {class_id} -> {class_name, year, semester, credit}
- {stu_id, class_id} -> {grade}

### 자명한 함수 종속 (Trivial Functional Dependency)

X -> Y 이고 Y가 X의 부분집합 일때, X -> Y는 자명한 함수 종속성을 가지고 있다고 표현한다.

{ a, b, c } -> { c }
{ a, b, c } -> { a, c }
{ a, b, c } -> { a, b, c }

### 부분적 함수 종속 (Partial Functional Dependency)
X -> Y 이고, X의 부분집합이 Y를 결정 지을 수 있다면 X -> Y는 부분적 함수 종속성을 가지고 있다고 표현한다.

마찬가지로 직원을 관리하는 테이블의 empl_id (pk), empl_name, birth_date라는 속성이 있다고 가정해보자.

{empl_id, empl_name} -> {birth_date}를 만족할 때, X의 부분집합에 해당되는 {empl_id}만으로도 생년월일을 구별할 수 있으므로 아래와 같이 표현할 수 있다.
```
{empl_id} -> {birth_date}
```

결론적으로 {empl_id, empl_name} -> {birth_date} 함수 종속성은 부분적 함수 종속성을 가지고 있다고 볼 수 있다.

### 완전한 함수 종속 (Full Functional Dependency)
X -> Y이고, X의 부분집합이 Y를 **결정지을 수 없다면** X -> Y는 완전한 함수 종속성을 가지고 있다고 표현한다.

예시로 {stu_id, class_id} -> {grade} 라는 함수적 종속이 있다고 가정할 때, X의 부분집합인 {stu_id}, {class_id}, {}는 gradle(성적)을 결정할 수 없다.

## 정규화
정규화란 데이터 중복과 삽입, 수정, 삭제에서 발생하는 이상현상을 최소화하기 위해 정규화 규칙을 통해 관계형 데이터베이스를 설계하는 것이다. 각 정규화 과정을 순차적으로 진행하며 조건을 만족하지 못하면 다음 정규화 과정으로 넘어갈 수 없다는 특징이 있다.

보통 실무에서는 제 3정규화 혹은 BCNF 정규화까지만 진행한다는 특징이 있다.

예를 들어 월급 계좌를 관리하는 employee_account라는 테이블이 아래와 같은 구조로 설계되었다고 가정해보자. 해당 테이블의 조건은 다음과 같다

- 월급 계좌는 국민은행, 우리은행 중 하나를 선택할 수 있다
- 한 임직원이 하나 이상의 월급 계좌를 등록하고 월급 비율을 조정할 수 있다
- 계좌마다 등급이 존재한다. 등급은 국민은행과 우리은행이 사용하는 값이 다르다
- 한 계좌는 하나 이상의 현금 카드와 연동된다

| account_id | account_num | bank_name | class | ratio | empl_id | empl_name | card_id |
| --- | --- | --- | --- | --- | --- | --- | --- |

위 테이블에 대한 주요 함수적 종속성을 찾아보면 아래와 같다.
- {account_id} -> {account_num, bank_name, class, ratio .... }
- {account_num, bank_name} -> {account_id, class, ratio .... }
- {empl_id} -> {empl_name}
- {class} -> {bank_name}

### 제 1정규화
제 1정규화에 대한 규칙은 다음과 같다.
```
Attribute의 값은 반드시 나눠질 수 없는 단일한 값이어야 한다.
```

아래와 같이 테이블에 로우가 있다고 가정해보자. 아래 테이블의 pk는 account_id 컬럼이다.
| account_id | account_num | bank_name | class | ratio | empl_id | empl_name | card_id |
| --- | --- | --- | --- | --- | --- | --- | --- |
| a11 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 | Sonny | c101 |
| a12 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | Sonny | c102 |
| a13 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | Sonny | c103 |
| a21 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | c201, c202 |

Sonny는 월급을 3개의 계좌 (a11, a12, a13)으로 나눠받기로 했다. Messi는 1개의 계좌로 월급을 나눠받고 2개의 카드 (c201, c202)가 계좌에 등록되어 있다.

Messi가 가지고 있는 card_id 속성의 값은 단일한 값이 아닌 c201, c202의 값을 가지고 있으므로 제 1정규화 규칙을 위배한다고 볼 수 있다.

위 테이블이 제 1정규화를 만족하려면 card_id가 c202에 대한 로우를 아래와 같이 생성해줘야 한다. 하지만 단순히 로우만 추가할 경우 pk였던 account_id 컬럼에 대한 값이 중복되므로 account_id와 card_id로 구성된 복합키로 테이블을 구성해야 한다.
| account_id | card_id |  account_num | bank_name | class | ratio | empl_id | empl_name |
| --- | --- | --- | --- | --- | --- | --- | --- |
| a11 | c101 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 | Sonny | 
| a12 | c102 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | Sonny | 
| a13 | c103 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | Sonny | 
| a21 | c201 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 
| a21 | c202 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 


### 제 2정규화
제 2정규화에 대한 규칙은 다음과 같다.
```
PK가 여러 키로 구성된 복합키로 구성된 경우, 복합키를 제외한 다른 속성들이 완전한 함수 종속을 만족해야 한다.
```

| account_id | card_id |  account_num | bank_name | class | ratio | empl_id | empl_name |
| --- | --- | --- | --- | --- | --- | --- | --- |
| a11 | c101 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 | Sonny | 
| a12 | c102 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | Sonny | 
| a13 | c103 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | Sonny | 
| a21 | c201 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 
| a21 | c202 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 

아래 테이블의 함수적 종속관계 중 하나를 예시로 들자면 아래와 같다.

{account_id, card_id} -> {class, ratio, empl_id, empl_name}

하지만 굳이 account_id 없이도 card_id 컬럼만으로도 아래와 같이 Y를 구분 지을 수 있다. 따라서 복합키에 대한 부분적 함수 종속이 발생하여 완전한 함수 종속성을 만족시킨다고 볼 수 없다.

{card_id} -> {class, ratio, empl_id, empl_name}

따라서 제 2정규화 규칙을 만족하려면 아래와 같이 테이블은 분리해야 한다.

**employee_account**
| account_id | account_num | bank_name | class | ratio | empl_id | empl_name |
| --- | --- | --- | --- | --- | --- | --- |
| a11 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 | Sonny | 
| a12 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | Sonny | 
| a13 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | Sonny | 
| a21 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 

**account_card**
| account_id | card_id |
| --- | --- | 
| a11 | c101 | 
| a12 | c102 | 
| a13 | c103 | 
| a21 | c201 | 
| a21 | c202 | 

### 제 3정규화
제 3정규화에 대한 규칙은 다음과 같다.
```
제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애야 한다.
```

앞서 제 2정규화를 만족시킨 employee_account 테이블을 확인해보자. empl_id와 empl_name 컬럼에 대한 데이터 중복이 발생하는것을 확인할 수 있다.  

**employee_account**
| account_id | account_num | bank_name | class | ratio | empl_id | empl_name |
| --- | --- | --- | --- | --- | --- | --- |
| a11 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 | Sonny | 
| a12 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | Sonny | 
| a13 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | Sonny | 
| a21 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | Messi | 

위 테이블에서 아래와 같은 함수적 종속성을 확인할 수 있다.

- {account_id} -> {empl_id}
- {bank_name, account_num} -> {empl_id}
- {empl_id} -> {empl_name}

종속성 간의 empl_id가 중복되는것을 확인할 수 있다 최종적으로 {account_id} -> {empl_name}, {bank_name, account_num} -> {empl_name}의 종속성을 가지는 것을 확인할 수 있다.

위 예시처럼 X를 account_id, Y를 empl_id, Z를 empl_name이라고 할 때, X -> Y, Y -> Z가 성립되고 X -> Z 또한 성립된다. **이를 이행적 종속이 성립된다고 한다.** 즉 기본키 이외에 다른 컬럼이 그 외의 컬럼을 결정할 수 있다는 의미를 가진다. 

따라서 제 3정규화를 만족하기 위해서는 employee_account 테이블을 아래와 같이 분리시켜야 한다.

**employee_account**
| account_id | account_num | bank_name | class | ratio | empl_id |
| --- | --- | --- | --- | --- | --- | 
| a11 | 010-1234-1234 | Woori | BRONZE | 0.1 | e1 |
| a12 | 102-000-123023 | Woori | SILVER | 0.2 | e1 | 
| a13 | 010-1234-1234 | Kookmin | LOYAL | 0.7 | e1 | 
| a21 | 010-2222-2222 | Kookmin | LOYAL | 1 | e2 | 

**employee**
| empl_id | empl_name |
| --- | --- |
| e1 | Sonny | 
| e2 | Messi | 

