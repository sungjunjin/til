# 디자인패턴

디자인 패턴이란 실제 개발 현장에서 많은 사람들이 인정한 객체 지향 프로그래밍의 베스트 프렉티스를 모아놓은 패턴들의 모음이다.

디자인 패턴은 객체지향의 다음과 같은 특성을 활용하여 구성된다
- 상속
- 인터페이스
- 합성 (객체를 클래스 멤버로 활용)

## 어댑터 패턴 (Adapter Pattern)
래퍼 (Wrapper) 패턴이라고도 불린다. 기존 클래스를 새로운 wrapper 클래스로 감싸 어댑터 클래스를 만든 뒤 기존 클래스의 메소드를 어댑터 클래스의 메소드에서 호출하는 방법이다.

### wrapper 클래스를 사용해 기존 메소드의 시그니처 바꾸기
어떤 클래스의 메소드 시그니처를 해당 클래스의 소스코드를 변경하지 않고 (다른 코드가 사용할 수 있기 때문에) wrapper 클래스를 사용해 바꿀 수 있다. 주로 레거시 클래스를 새로운 클래스로 교체할때 사용되는 패턴이다.

아래와 같은 ServiceA 클래스가 있다고 하자.
```java
public class ServiceA {

    void runServiceA() {
        System.out.println("run service A");
    }
}
```

예시로 새로운 인터페이스를 정의하고 싶은 순간에 runServiceA의 메소드 시그니처를 바꿔서 호출하고 싶은 경우가 있다. 이럴 때 아래와 같이 wrapper 클래스를 활용하여 기존 클래스를 수정하지 않고 runServiceA 메소드를 내부적으로 호출하는 wrapper 클래스의 메소드를 새롭게 정의하여 사용할 수 있다.

```java
public class AdapterServiceA {
    Service service = new Service();

    // 새로운 메소드 시그니처
    void runService() {
        // 기존 클래스의 메소드를 내부적으로 호출
        service.runService();
    }
}
```

메소드 시그니처를 변경하는 것 외에 Adapter 패턴은 다음과 같은 용도로 사용할 수 있다
- 내부 클래스를 클라이언트에 노출시키지 않기 위해
- 기존 클래스를 변경하지 않고 기능을 확장하기 위해

## 프록시 패턴(Proxy Pattern)
프록시 패턴은 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 패턴이다. 중간에 proxy(대리) 객체를 두어 원본 객체를 내부적으로 사용한다. 프록시 클래스는 원본 객체의 입력값과 반환값을 그대로 유지하고 제어에 대한 흐름만 담당한다.

프록시 패턴은 다음과 같은 상황에서 사용한다
- 보안 : 클라이언트가 작업을 수행할 수 있는 권한을 가졌는지 중간에서 검증할 수 있다
- 캐싱 : 원본 객체의 처리결과에 대한 내부 캐시를 유지하여 원본 객체를 호출하지 않고 중간에서 직접 처리할 수 있다
- 데이터 유효성 검사 : 데이터 원본 객체로 전달하기 전에 데이터에 대한 유효성 검증을 수행할 수 있다
- 지연 초기화 : 대상 객체의 생성 비용이 비싸다면 프록시 객체가 그것을 필요로 할때까지 연기할 수 있다
- 로깅 : 원본 객체의 메소드를 수행하기 전에 입력값이나 상태를 기록할 수 있다
- 원격 객체 : 어플리케이션 외부에 있는 원격 객체를 가져와 로컬처럼 보이게 할 수 있다

```mermaid
flowchart LR
client[Client]
proxy[Proxy]
service[대상 원본 객체]

client --- proxy --- service
```

프록시 패턴에 대한 코드 예시는 아래와 같다
```java
// 원본 객체
public class Service implements IService{
    @Override
    public void runSomething() {
        System.out.println("running service");
    }
}
```

실제 작업을 수행하는 원본 객체를 구현한다.

```java
public class Proxy implements IService {

    IService service;

    Proxy(Service service) {
        this.service = service;
    }

    @Override
    public void runSomething() {
        
        // 추가적인 작업 진행

        // 원본 객체를 내부적으로 호출
        service.runSomething();
    }
}

```
원본 객체를 멤버로 갖는 프록시 클래스를 정의한다. 프록시 클래스에서 호출할 runSomething 메소드는 실제 원본 객체의 작업 메소드를 호출전에 유효성 검사나 지연 초기화 같은 추가적인 작업을 먼저 실행할 수 있다.


## 데코레이터 패턴(Decorator Pattern)
데코레이터 패턴은 메소드 호출의 반환값의 변화를 주기 위해 중간에 장식자를 두는 패턴이다.

데코레이터 패턴은 프록시 패턴과 일반적으로 구성은 같지만, 원본 객체의 반환값을 수정하지 않는 프록시 패턴과는 다르게 데코레이터 패턴은 원본 객체가 돌려주는 반환값에 장식(decorator)을 더하여 클라이언트에게 전달한다.


데코레이터 패턴에 대한 코드 예시는 아래와 같다

```java
public class Service implements IService {
    @Override
    public String runSomething() {
        System.out.println("running service");

        return "running service";
    }
}
```

실제 작업을 수행하는 원본 객체를 구현한다. 원본 객체의 runSomething 메소드는 "running service"라는 문자열 값을 반환한다.

```java
public class Decorator {
    private IService service;

    Decorator(Service service) {
        this.service = service;
    }

    public String runSomeThing() {
        // 반환값의 변화를 준다
        return "decorator pattern" + runSomeThing();
    }
}
```
원본 객체를 멤버로 갖는 데코레이터 클래스를 정의한다. 원본 객체의 runSomeThing 메소드를 호출하는 메소드를 정의해 반환값에 대한 변화를 준다. 